diff --git a/salt/modules/aixpkg.py b/salt/modules/aixpkg.py
index a98b5de291baa..f272b846305d6 100644
--- a/salt/modules/aixpkg.py
+++ b/salt/modules/aixpkg.py
@@ -386,7 +386,7 @@ def latest_version(*names, **kwargs):
 )
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
diff --git a/salt/modules/apkpkg.py b/salt/modules/apkpkg.py
index 2075b27374057..048104ae9f92f 100644
--- a/salt/modules/apkpkg.py
+++ b/salt/modules/apkpkg.py
@@ -83,7 +83,7 @@ def version(*names, **kwargs):
     return __salt__["pkg_resource.version"](*names, **kwargs)
 
 
-def refresh_db():
+def refresh_db(**kwargs):
     """
     Updates the package list
 
@@ -409,7 +409,7 @@ def remove(
     return ret
 
 
-def upgrade(name=None, pkgs=None, refresh=True):
+def upgrade(name=None, pkgs=None, refresh=True, **kwargs):
     """
     Upgrades all packages via ``apk upgrade`` or a specific package if name or
     pkgs is specified. Name is ignored if pkgs is specified
@@ -469,7 +469,7 @@ def upgrade(name=None, pkgs=None, refresh=True):
     return ret
 
 
-def list_upgrades(refresh=True):
+def list_upgrades(refresh=True, **kwargs):
     """
     List all available package upgrades.
 
@@ -506,7 +506,7 @@ def list_upgrades(refresh=True):
     return ret
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of _every_ file on the system's package database (not
@@ -523,7 +523,7 @@ def file_list(*packages):
     return file_dict(*packages)
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, grouped by package. Not
     specifying any packages will return a list of _every_ file on the system's
@@ -560,7 +560,7 @@ def file_dict(*packages):
     return {"errors": errors, "packages": ret}
 
 
-def owner(*paths):
+def owner(*paths, **kwargs):
     """
     Return the name of the package that owns the file. Multiple file paths can
     be passed. Like :mod:`pkg.version <salt.modules.apk.version`, if a single
diff --git a/salt/modules/aptpkg.py b/salt/modules/aptpkg.py
index 5c81379d311fe..86988ed773caf 100644
--- a/salt/modules/aptpkg.py
+++ b/salt/modules/aptpkg.py
@@ -348,7 +348,7 @@ def version(*names, **kwargs):
     return __salt__["pkg_resource.version"](*names, **kwargs)
 
 
-def refresh_db(cache_valid_time=0, failhard=False):
+def refresh_db(cache_valid_time=0, failhard=False, **kwargs):
     """
     Updates the APT database to latest packages based upon repositories
 
@@ -1456,7 +1456,7 @@ def list_upgrades(refresh=True, dist_upgrade=True, **kwargs):
     return _get_upgradable(dist_upgrade, **kwargs)
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
@@ -1469,7 +1469,7 @@ def upgrade_available(name):
     return latest_version(name) != ""
 
 
-def version_cmp(pkg1, pkg2, ignore_epoch=False):
+def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):
     """
     Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if
     pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
@@ -1674,7 +1674,7 @@ def _skip_source(source):
     return False
 
 
-def list_repos():
+def list_repos(**kwargs):
     """
     Lists all repos in the sources.list (and sources.lists.d) files
 
@@ -2490,7 +2490,7 @@ def mod_repo(repo, saltenv="base", **kwargs):
     }
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of _every_ file on the system's package database (not
@@ -2507,7 +2507,7 @@ def file_list(*packages):
     return __salt__["lowpkg.file_list"](*packages)
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, grouped by package. Not
     specifying any packages will return a list of _every_ file on the system's
@@ -2783,7 +2783,7 @@ def _resolve_deps(name, pkgs, **kwargs):
     return
 
 
-def owner(*paths):
+def owner(*paths, **kwargs):
     """
     .. versionadded:: 2014.7.0
 
diff --git a/salt/modules/dpkg_lowpkg.py b/salt/modules/dpkg_lowpkg.py
index 1bbde26fbc534..e267eea51bb65 100644
--- a/salt/modules/dpkg_lowpkg.py
+++ b/salt/modules/dpkg_lowpkg.py
@@ -134,7 +134,7 @@ def unpurge(*packages):
     return salt.utils.data.compare_dicts(old, new)
 
 
-def list_pkgs(*packages):
+def list_pkgs(*packages, **kwargs):
     """
     List the packages currently installed in a dict::
 
@@ -170,7 +170,7 @@ def list_pkgs(*packages):
     return pkgs
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of _every_ file on the system's package database (not
@@ -205,7 +205,7 @@ def file_list(*packages):
     return {"errors": errors, "files": sorted(ret)}
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, grouped by package. Not
     specifying any packages will return a list of _every_ file on the system's
diff --git a/salt/modules/ebuildpkg.py b/salt/modules/ebuildpkg.py
index 60952bda0a974..4eef2382fc655 100644
--- a/salt/modules/ebuildpkg.py
+++ b/salt/modules/ebuildpkg.py
@@ -375,7 +375,7 @@ def list_upgrades(refresh=True, backtrack=3, **kwargs):  # pylint: disable=W0613
     return _get_upgradable(backtrack)
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
@@ -456,7 +456,7 @@ def list_pkgs(versions_as_list=False, **kwargs):
     return ret
 
 
-def refresh_db():
+def refresh_db(**kwargs):
     """
     Update the portage tree using the first available method from the following
     list:
@@ -794,7 +794,7 @@ def install(
     return changes
 
 
-def update(pkg, slot=None, fromrepo=None, refresh=False, binhost=None):
+def update(pkg, slot=None, fromrepo=None, refresh=False, binhost=None, **kwargs):
     """
     .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
         On minions running systemd>=205, `systemd-run(1)`_ is now used to
@@ -881,7 +881,7 @@ def update(pkg, slot=None, fromrepo=None, refresh=False, binhost=None):
     return ret
 
 
-def upgrade(refresh=True, binhost=None, backtrack=3):
+def upgrade(refresh=True, binhost=None, backtrack=3, **kwargs):
     """
     .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
         On minions running systemd>=205, `systemd-run(1)`_ is now used to
diff --git a/salt/modules/freebsdpkg.py b/salt/modules/freebsdpkg.py
index b5680b39a2f93..12ecc6e0e1fac 100644
--- a/salt/modules/freebsdpkg.py
+++ b/salt/modules/freebsdpkg.py
@@ -254,7 +254,7 @@ def version(*names, **kwargs):
     )
 
 
-def refresh_db():
+def refresh_db(**kwargs):
     """
     ``pkg_add(1)`` does not use a local database of available packages, so this
     function simply returns ``True``. it exists merely for API compatibility.
@@ -514,7 +514,7 @@ def _rehash():
         __salt__["cmd.shell"]("rehash", output_loglevel="trace")
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of _every_ file on the system's package database (not
@@ -536,7 +536,7 @@ def file_list(*packages):
     return ret
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, grouped by package. Not
     specifying any packages will return a list of _every_ file on the
diff --git a/salt/modules/mac_brew_pkg.py b/salt/modules/mac_brew_pkg.py
index f537ef683bb9a..c61c8b86e0807 100644
--- a/salt/modules/mac_brew_pkg.py
+++ b/salt/modules/mac_brew_pkg.py
@@ -298,7 +298,7 @@ def remove(name=None, pkgs=None, **kwargs):
     return ret
 
 
-def refresh_db():
+def refresh_db(**kwargs):
     """
     Update the homebrew package repository.
 
@@ -481,7 +481,7 @@ def list_upgrades(refresh=True, **kwargs):  # pylint: disable=W0613
     return ret
 
 
-def upgrade_available(pkg):
+def upgrade_available(pkg, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
@@ -494,7 +494,7 @@ def upgrade_available(pkg):
     return pkg in list_upgrades()
 
 
-def upgrade(refresh=True):
+def upgrade(refresh=True, **kwargs):
     """
     Upgrade outdated, unpinned brews.
 
@@ -540,7 +540,7 @@ def upgrade(refresh=True):
     return ret
 
 
-def info_installed(*names):
+def info_installed(*names, **kwargs):
     """
     Return the information of the named package(s) installed on the system.
 
diff --git a/salt/modules/mac_portspkg.py b/salt/modules/mac_portspkg.py
index a5218dd44ac96..9b19a3ad82818 100644
--- a/salt/modules/mac_portspkg.py
+++ b/salt/modules/mac_portspkg.py
@@ -381,7 +381,7 @@ def list_upgrades(refresh=True, **kwargs):  # pylint: disable=W0613
     return _list("outdated")
 
 
-def upgrade_available(pkg, refresh=True):
+def upgrade_available(pkg, refresh=True, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
@@ -394,7 +394,7 @@ def upgrade_available(pkg, refresh=True):
     return pkg in list_upgrades(refresh=refresh)
 
 
-def refresh_db():
+def refresh_db(**kwargs):
     """
     Update ports with ``port selfupdate``
 
@@ -410,7 +410,7 @@ def refresh_db():
     return salt.utils.mac_utils.execute_return_success(cmd)
 
 
-def upgrade(refresh=True):  # pylint: disable=W0613
+def upgrade(refresh=True, **kwargs):  # pylint: disable=W0613
     """
     Run a full upgrade using MacPorts 'port upgrade outdated'
 
diff --git a/salt/modules/openbsdpkg.py b/salt/modules/openbsdpkg.py
index f80c9bc62a947..2fad4426671e6 100644
--- a/salt/modules/openbsdpkg.py
+++ b/salt/modules/openbsdpkg.py
@@ -341,7 +341,7 @@ def purge(name=None, pkgs=None, **kwargs):
     return remove(name=name, pkgs=pkgs, purge=True)
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
diff --git a/salt/modules/pacmanpkg.py b/salt/modules/pacmanpkg.py
index 41eb7b54bb791..73f3740e5783e 100644
--- a/salt/modules/pacmanpkg.py
+++ b/salt/modules/pacmanpkg.py
@@ -112,7 +112,7 @@ def latest_version(*names, **kwargs):
 )
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
@@ -401,7 +401,7 @@ def group_diff(name):
     return ret
 
 
-def refresh_db(root=None):
+def refresh_db(root=None, **kwargs):
     """
     Just run a ``pacman -Sy``, return a dict::
 
@@ -836,7 +836,7 @@ def purge(name=None, pkgs=None, **kwargs):
     return _uninstall(action="purge", name=name, pkgs=pkgs)
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of _every_ file on the system's package database (not
@@ -870,7 +870,7 @@ def file_list(*packages):
     return {"errors": errors, "files": ret}
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, grouped by package. Not
     specifying any packages will return a list of _every_ file on the system's
@@ -906,7 +906,7 @@ def file_dict(*packages):
     return {"errors": errors, "packages": ret}
 
 
-def owner(*paths):
+def owner(*paths, **kwargs):
     """
     .. versionadded:: 2014.7.0
 
diff --git a/salt/modules/pkgin.py b/salt/modules/pkgin.py
index 003c17b7cf0ad..b2931bf0be505 100644
--- a/salt/modules/pkgin.py
+++ b/salt/modules/pkgin.py
@@ -115,7 +115,7 @@ def _splitpkg(name):
         return name.split(";", 1)[0].rsplit("-", 1)
 
 
-def search(pkg_name):
+def search(pkg_name, **kwargs):
     """
     Searches for an exact match using pkgin ^package$
 
@@ -227,7 +227,7 @@ def version(*names, **kwargs):
     return __salt__["pkg_resource.version"](*names, **kwargs)
 
 
-def refresh_db(force=False):
+def refresh_db(force=False, **kwargs):
     """
     Use pkg update to get latest pkg_summary
 
@@ -640,7 +640,7 @@ def _rehash():
         __salt__["cmd.run"]("rehash", output_loglevel="trace")
 
 
-def file_list(package):
+def file_list(package, **kwargs):
     """
     List the files that belong to a package.
 
@@ -658,7 +658,7 @@ def file_list(package):
     return ret
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     .. versionchanged: 2016.3.0
 
diff --git a/salt/modules/pkgng.py b/salt/modules/pkgng.py
index fdc15456a61e8..bcb56c161919f 100644
--- a/salt/modules/pkgng.py
+++ b/salt/modules/pkgng.py
@@ -230,7 +230,7 @@ def version(*names, **kwargs):
 info = salt.utils.functools.alias_function(version, "info")
 
 
-def refresh_db(jail=None, chroot=None, root=None, force=False):
+def refresh_db(jail=None, chroot=None, root=None, force=False, **kwargs):
     """
     Refresh PACKAGESITE contents
 
@@ -2445,7 +2445,7 @@ def _parse_upgrade(stdout):
     return result
 
 
-def version_cmp(pkg1, pkg2, ignore_epoch=False):
+def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):
     """
     Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if
     pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
diff --git a/salt/modules/rpm_lowpkg.py b/salt/modules/rpm_lowpkg.py
index abebbbdab9f97..9e4b8b2e8c041 100644
--- a/salt/modules/rpm_lowpkg.py
+++ b/salt/modules/rpm_lowpkg.py
@@ -90,7 +90,7 @@ def bin_pkg_info(path, saltenv="base"):
         minion so that it can be examined.
 
     saltenv : base
-        Salt fileserver envrionment from which to retrieve the package. Ignored
+        Salt fileserver environment from which to retrieve the package. Ignored
         if ``path`` is a local file path on the minion.
 
     CLI Example:
@@ -134,12 +134,15 @@ def bin_pkg_info(path, saltenv="base"):
     return ret
 
 
-def list_pkgs(*packages):
+def list_pkgs(*packages, **kwargs):
     """
     List the packages currently installed in a dict::
 
         {'<package_name>': '<version>'}
 
+    root
+        use root as top level directory (default: "/")
+
     CLI Example:
 
     .. code-block:: bash
@@ -147,7 +150,10 @@ def list_pkgs(*packages):
         salt '*' lowpkg.list_pkgs
     """
     pkgs = {}
-    cmd = ["rpm", "-q" if packages else "-qa", "--queryformat", r"%{NAME} %{VERSION}\n"]
+    cmd = ["rpm"]
+    if kwargs.get("root"):
+        cmd.extend(["--root", kwargs["root"]])
+    cmd.extend(["-q" if packages else "-qa", "--queryformat", r"%{NAME} %{VERSION}\n"])
     if packages:
         cmd.extend(packages)
     out = __salt__["cmd.run"](cmd, output_loglevel="trace", python_shell=False)
@@ -163,6 +169,9 @@ def verify(*packages, **kwargs):
     """
     Runs an rpm -Va on a system, and returns the results in a dict
 
+    root
+        use root as top level directory (default: "/")
+
     Files with an attribute of config, doc, ghost, license or readme in the
     package header can be ignored using the ``ignore_types`` keyword argument
 
@@ -202,6 +211,8 @@ def verify(*packages, **kwargs):
             ]
 
     cmd = ["rpm"]
+    if kwargs.get("root"):
+        cmd.extend(["--root", kwargs["root"]])
     cmd.extend(["--" + x for x in verify_options])
     if packages:
         cmd.append("-V")
@@ -260,6 +271,9 @@ def modified(*packages, **flags):
 
     .. versionadded:: 2015.5.0
 
+    root
+        use root as top level directory (default: "/")
+
     CLI examples:
 
     .. code-block:: bash
@@ -268,9 +282,12 @@ def modified(*packages, **flags):
         salt '*' lowpkg.modified httpd postfix
         salt '*' lowpkg.modified
     """
-    ret = __salt__["cmd.run_all"](
-        ["rpm", "-Va"] + list(packages), output_loglevel="trace", python_shell=False
-    )
+    cmd = ["rpm"]
+    if flags.get("root"):
+        cmd.extend(["--root", flags.pop("root")])
+    cmd.append("-Va")
+    cmd.extend(packages)
+    ret = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
 
     data = {}
 
@@ -333,12 +350,15 @@ def modified(*packages, **flags):
     return filtered_data
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of _every_ file on the system's rpm database (not generally
     recommended).
 
+    root
+        use root as top level directory (default: "/")
+
     CLI Examples:
 
     .. code-block:: bash
@@ -347,24 +367,30 @@ def file_list(*packages):
         salt '*' lowpkg.file_list httpd postfix
         salt '*' lowpkg.file_list
     """
-    if not packages:
-        cmd = ["rpm", "-qla"]
-    else:
-        cmd = ["rpm", "-ql"]
+    cmd = ["rpm"]
+    if kwargs.get("root"):
+        cmd.extend(["--root", kwargs["root"]])
+
+    cmd.append("-ql" if packages else "-qla")
+    if packages:
         # Can't concatenate a tuple, must do a list.extend()
         cmd.extend(packages)
+
     ret = __salt__["cmd.run"](
         cmd, output_loglevel="trace", python_shell=False
     ).splitlines()
     return {"errors": [], "files": ret}
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, sorted by group. Not specifying
     any packages will return a list of _every_ file on the system's rpm
     database (not generally recommended).
 
+    root
+        use root as top level directory (default: "/")
+
     CLI Examples:
 
     .. code-block:: bash
@@ -376,7 +402,10 @@ def file_dict(*packages):
     errors = []
     ret = {}
     pkgs = {}
-    cmd = ["rpm", "-q" if packages else "-qa", "--queryformat", r"%{NAME} %{VERSION}\n"]
+    cmd = ["rpm"]
+    if kwargs.get("root"):
+        cmd.extend(["--root", kwargs["root"]])
+    cmd.extend(["-q" if packages else "-qa", "--queryformat", r"%{NAME} %{VERSION}\n"])
     if packages:
         cmd.extend(packages)
     out = __salt__["cmd.run"](cmd, output_loglevel="trace", python_shell=False)
@@ -387,8 +416,10 @@ def file_dict(*packages):
         comps = line.split()
         pkgs[comps[0]] = {"version": comps[1]}
     for pkg in pkgs:
-        files = []
-        cmd = ["rpm", "-ql", pkg]
+        cmd = ["rpm"]
+        if kwargs.get("root"):
+            cmd.extend(["--root", kwargs["root"]])
+        cmd.extend(["-ql", pkg])
         out = __salt__["cmd.run"](
             ["rpm", "-ql", pkg], output_loglevel="trace", python_shell=False
         )
@@ -396,7 +427,7 @@ def file_dict(*packages):
     return {"errors": errors, "packages": ret}
 
 
-def owner(*paths):
+def owner(*paths, **kwargs):
     """
     Return the name of the package that owns the file. Multiple file paths can
     be passed. If a single path is passed, a string will be returned,
@@ -406,6 +437,9 @@ def owner(*paths):
     If the file is not owned by a package, or is not present on the minion,
     then an empty string will be returned for that path.
 
+    root
+        use root as top level directory (default: "/")
+
     CLI Examples:
 
     .. code-block:: bash
@@ -417,7 +451,10 @@ def owner(*paths):
         return ""
     ret = {}
     for path in paths:
-        cmd = ["rpm", "-qf", "--queryformat", "%{name}", path]
+        cmd = ["rpm"]
+        if kwargs.get("root"):
+            cmd.extend(["--root", kwargs["root"]])
+        cmd.extend(["-qf", "--queryformat", "%{name}", path])
         ret[path] = __salt__["cmd.run_stdout"](
             cmd, output_loglevel="trace", python_shell=False
         )
@@ -477,6 +514,9 @@ def info(*packages, **kwargs):
     :param all_versions:
         Return information for all installed versions of the packages
 
+    :param root:
+        use root as top level directory (default: "/")
+
     :return:
 
     CLI example:
@@ -499,7 +539,14 @@ def info(*packages, **kwargs):
     else:
         size_tag = "%{SIZE}"
 
-    cmd = packages and "rpm -q {0}".format(" ".join(packages)) or "rpm -qa"
+    cmd = ["rpm"]
+    if kwargs.get("root"):
+        cmd.extend(["--root", kwargs["root"]])
+    if packages:
+        cmd.append("-q")
+        cmd.extend(packages)
+    else:
+        cmd.append("-qa")
 
     # Construct query format
     attr_map = {
@@ -550,6 +597,7 @@ def info(*packages, **kwargs):
         query.append(attr_map["description"])
     query.append("-----\\n")
 
+    cmd = " ".join(cmd)
     call = __salt__["cmd.run_all"](
         cmd + (" --queryformat '{0}'".format("".join(query))),
         output_loglevel="trace",
@@ -758,10 +806,13 @@ def _prepend(ver):
     return salt.utils.versions.version_cmp(ver1, ver2, ignore_epoch=False)
 
 
-def checksum(*paths):
+def checksum(*paths, **kwargs):
     """
     Return if the signature of a RPM file is valid.
 
+    root
+        use root as top level directory (default: "/")
+
     CLI Example:
 
     .. code-block:: bash
@@ -774,14 +825,16 @@ def checksum(*paths):
     if not paths:
         raise CommandExecutionError("No package files has been specified.")
 
+    cmd = ["rpm"]
+    if kwargs.get("root"):
+        cmd.extend(["--root", kwargs["root"]])
+    cmd.extend(["-K", "--quiet"])
     for package_file in paths:
+        cmd_ = cmd + [package_file]
         ret[package_file] = bool(
             __salt__["file.file_exists"](package_file)
         ) and not __salt__["cmd.retcode"](
-            ["rpm", "-K", "--quiet", package_file],
-            ignore_retcode=True,
-            output_loglevel="trace",
-            python_shell=False,
+            cmd_, ignore_retcode=True, output_loglevel="trace", python_shell=False
         )
 
     return ret
diff --git a/salt/modules/solarisipspkg.py b/salt/modules/solarisipspkg.py
index 639e605d9e6b6..4d0853b3fc905 100644
--- a/salt/modules/solarisipspkg.py
+++ b/salt/modules/solarisipspkg.py
@@ -109,7 +109,7 @@ def _ips_get_pkgversion(line):
     return line.split()[0].split("@")[1].strip()
 
 
-def refresh_db(full=False):
+def refresh_db(full=False, **kwargs):
     """
     Updates the remote repos database.
 
@@ -133,7 +133,7 @@ def refresh_db(full=False):
         return __salt__["cmd.retcode"]("/bin/pkg refresh") == 0
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check if there is an upgrade available for a certain package
     Accepts full or partial FMRI. Returns all matches found.
diff --git a/salt/modules/solarispkg.py b/salt/modules/solarispkg.py
index 032d9db017e5e..2016c2e9f0cf9 100644
--- a/salt/modules/solarispkg.py
+++ b/salt/modules/solarispkg.py
@@ -176,7 +176,7 @@ def latest_version(*names, **kwargs):
 )
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
diff --git a/salt/modules/xbpspkg.py b/salt/modules/xbpspkg.py
index 3da001c750dd1..29302714a4595 100644
--- a/salt/modules/xbpspkg.py
+++ b/salt/modules/xbpspkg.py
@@ -121,7 +121,7 @@ def list_pkgs(versions_as_list=False, **kwargs):
     return ret
 
 
-def list_upgrades(refresh=True):
+def list_upgrades(refresh=True, **kwargs):
     """
     Check whether or not an upgrade is available for all packages
 
@@ -241,7 +241,7 @@ def latest_version(*names, **kwargs):
 available_version = latest_version
 
 
-def upgrade_available(name):
+def upgrade_available(name, **kwargs):
     """
     Check whether or not an upgrade is available for a given package
 
@@ -254,7 +254,7 @@ def upgrade_available(name):
     return latest_version(name) != ""
 
 
-def refresh_db():
+def refresh_db(**kwargs):
     """
     Update list of available packages from installed repos
 
@@ -294,7 +294,7 @@ def version(*names, **kwargs):
     return __salt__["pkg_resource.version"](*names, **kwargs)
 
 
-def upgrade(refresh=True):
+def upgrade(refresh=True, **kwargs):
     """
     Run a full system upgrade
 
@@ -473,7 +473,7 @@ def remove(name=None, pkgs=None, recursive=True, **kwargs):
     return salt.utils.data.compare_dicts(old, new)
 
 
-def list_repos():
+def list_repos(**kwargs):
     """
     List all repos known by XBPS
 
@@ -594,7 +594,7 @@ def add_repo(repo, conffile="/usr/share/xbps.d/15-saltstack.conf"):
     return True
 
 
-def del_repo(repo):
+def del_repo(repo, **kwargs):
     """
     Remove an XBPS repository from the system.
 
diff --git a/salt/modules/yumpkg.py b/salt/modules/yumpkg.py
index 9c6a808487e5b..3c059ddb159b4 100644
--- a/salt/modules/yumpkg.py
+++ b/salt/modules/yumpkg.py
@@ -629,7 +629,7 @@ def version(*names, **kwargs):
     return __salt__["pkg_resource.version"](*names, **kwargs)
 
 
-def version_cmp(pkg1, pkg2, ignore_epoch=False):
+def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):
     """
     .. versionadded:: 2015.5.4
 
@@ -1025,7 +1025,7 @@ def list_upgrades(refresh=True, **kwargs):
 list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
 
 
-def list_downloaded():
+def list_downloaded(**kwargs):
     """
     .. versionadded:: 2017.7.0
 
@@ -2689,7 +2689,7 @@ def group_install(name, skip=(), include=(), **kwargs):
 groupinstall = salt.utils.functools.alias_function(group_install, "groupinstall")
 
 
-def list_repos(basedir=None):
+def list_repos(basedir=None, **kwargs):
     """
     Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).
 
@@ -3007,7 +3007,7 @@ def _parse_repo_file(filename):
     return (headers, salt.utils.data.decode(config))
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     .. versionadded:: 2014.1.0
 
@@ -3026,7 +3026,7 @@ def file_list(*packages):
     return __salt__["lowpkg.file_list"](*packages)
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     .. versionadded:: 2014.1.0
 
@@ -3045,7 +3045,7 @@ def file_dict(*packages):
     return __salt__["lowpkg.file_dict"](*packages)
 
 
-def owner(*paths):
+def owner(*paths, **kwargs):
     """
     .. versionadded:: 2014.7.0
 
@@ -3131,7 +3131,7 @@ def modified(*packages, **flags):
 
 
 @salt.utils.decorators.path.which("yumdownloader")
-def download(*packages):
+def download(*packages, **kwargs):
     """
     .. versionadded:: 2015.5.0
 
@@ -3205,7 +3205,7 @@ def download(*packages):
     return ret
 
 
-def diff(*paths):
+def diff(*paths, **kwargs):
     """
     Return a formatted diff between current files and original in a package.
     NOTE: this function includes all files (configuration and not), but does
@@ -3271,7 +3271,7 @@ def _get_patches(installed_only=False):
     return patches
 
 
-def list_patches(refresh=False):
+def list_patches(refresh=False, **kwargs):
     """
     .. versionadded:: 2017.7.0
 
@@ -3294,7 +3294,7 @@ def list_patches(refresh=False):
     return _get_patches()
 
 
-def list_installed_patches():
+def list_installed_patches(**kwargs):
     """
     .. versionadded:: 2017.7.0
 
diff --git a/salt/modules/zypperpkg.py b/salt/modules/zypperpkg.py
index 4af11cdef4b25..3210ed6bddfbb 100644
--- a/salt/modules/zypperpkg.py
+++ b/salt/modules/zypperpkg.py
@@ -103,6 +103,7 @@ class _Zypper(object):
 
     LOCK_EXIT_CODE = 7
     XML_DIRECTIVES = ["-x", "--xmlout"]
+    # ZYPPER_LOCK is not affected by --root
     ZYPPER_LOCK = "/var/run/zypp.pid"
     TAG_RELEASED = "zypper/released"
     TAG_BLOCKED = "zypper/blocked"
@@ -111,7 +112,6 @@ def __init__(self):
         """
         Constructor
         """
-        self.__called = False
         self._reset()
 
     def _reset(self):
@@ -133,6 +133,10 @@ def _reset(self):
         self.__refresh = False
         self.__ignore_repo_failure = False
         self.__systemd_scope = False
+        self.__root = None
+
+        # Call status
+        self.__called = False
 
     def __call__(self, *args, **kwargs):
         """
@@ -140,11 +144,17 @@ def __call__(self, *args, **kwargs):
         :param kwargs:
         :return:
         """
+        # Reset after the call
+        if self.__called:
+            self._reset()
+
         # Ignore exit code for 106 (repo is not available)
         if "no_repo_failure" in kwargs:
             self.__ignore_repo_failure = kwargs["no_repo_failure"]
         if "systemd_scope" in kwargs:
             self.__systemd_scope = kwargs["systemd_scope"]
+        if "root" in kwargs:
+            self.__root = kwargs["root"]
         return self
 
     def __getattr__(self, item):
@@ -157,7 +167,6 @@ def __getattr__(self, item):
         # Reset after the call
         if self.__called:
             self._reset()
-            self.__called = False
 
         if item == "xml":
             self.__xml = True
@@ -297,6 +306,8 @@ def __call(self, *args, **kwargs):
             self.__cmd.append("--xmlout")
         if not self.__refresh:
             self.__cmd.append("--no-refresh")
+        if self.__root:
+            self.__cmd.extend(["--root", self.__root])
 
         self.__cmd.extend(args)
         kwargs["output_loglevel"] = "trace"
@@ -493,11 +504,17 @@ def _clean_cache():
     """
     Clean cached results
     """
+    keys = []
     for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
-        __context__.pop(cache_name, None)
+        for contextkey in __context__:
+            if contextkey.startswith(cache_name):
+                keys.append(contextkey)
+
+    for key in keys:
+        __context__.pop(key, None)
 
 
-def list_upgrades(refresh=True, **kwargs):
+def list_upgrades(refresh=True, root=None, **kwargs):
     """
     List all available package upgrades on this system
 
@@ -506,6 +523,9 @@ def list_upgrades(refresh=True, **kwargs):
         If set to False it depends on zypper if a refresh is
         executed.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -513,7 +533,7 @@ def list_upgrades(refresh=True, **kwargs):
         salt '*' pkg.list_upgrades
     """
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     ret = dict()
     cmd = ["list-updates"]
@@ -529,7 +549,9 @@ def list_upgrades(refresh=True, **kwargs):
                 ]
             )
         log.debug("Targeting repos: %s", repos)
-    for update_node in __zypper__.nolock.xml.call(*cmd).getElementsByTagName("update"):
+    for update_node in (
+        __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
+    ):
         if update_node.getAttribute("kind") == "package":
             ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
 
@@ -566,6 +588,9 @@ def info_installed(*names, **kwargs):
     :param all_versions:
         Include information for all versions of the packages installed on the minion.
 
+    :param root:
+        Operate on a different root directory.
+
     CLI example:
 
     .. code-block:: bash
@@ -606,6 +631,9 @@ def info_available(*names, **kwargs):
         If set to False it depends on zypper if a refresh is
         executed or not.
 
+    root
+        operate on a different root directory.
+
     CLI example:
 
     .. code-block:: bash
@@ -620,9 +648,11 @@ def info_available(*names, **kwargs):
     else:
         names = sorted(list(set(names)))
 
+    root = kwargs.get("root", None)
+
     # Refresh db before extracting the latest package
     if kwargs.get("refresh", True):
-        refresh_db()
+        refresh_db(root)
 
     pkg_info = []
     batch = names[:]
@@ -633,7 +663,9 @@ def info_available(*names, **kwargs):
         pkg_info.extend(
             re.split(
                 r"Information for package*",
-                __zypper__.nolock.call("info", "-t", "package", *batch[:batch_size]),
+                __zypper__(root=root).nolock.call(
+                    "info", "-t", "package", *batch[:batch_size]
+                ),
             )
         )
         batch = batch[batch_size:]
@@ -692,6 +724,9 @@ def latest_version(*names, **kwargs):
         If set to False it depends on zypper if a refresh is
         executed or not.
 
+    root
+        operate on a different root directory.
+
     CLI example:
 
     .. code-block:: bash
@@ -736,6 +771,9 @@ def upgrade_available(name, **kwargs):
         If set to False it depends on zypper if a refresh is
         executed or not.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -752,6 +790,9 @@ def version(*names, **kwargs):
     installed. If more than one package name is specified, a dict of
     name/version pairs is returned.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -762,7 +803,7 @@ def version(*names, **kwargs):
     return __salt__["pkg_resource.version"](*names, **kwargs) or {}
 
 
-def version_cmp(ver1, ver2, ignore_epoch=False):
+def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
     """
     .. versionadded:: 2015.5.4
 
@@ -784,7 +825,7 @@ def version_cmp(ver1, ver2, ignore_epoch=False):
     return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
 
 
-def list_pkgs(versions_as_list=False, **kwargs):
+def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
     """
     List the packages currently installed as a dict. By default, the dict
     contains versions as a comma separated string::
@@ -796,6 +837,13 @@ def list_pkgs(versions_as_list=False, **kwargs):
 
         {'<package_name>': ['<version>', '<version>']}
 
+    root:
+        operate on a different root directory.
+
+    includes:
+        List of types of packages to include (package, patch, pattern, product)
+        By default packages are always included
+
     attr:
         If a list of package attributes is specified, returned value will
         contain them in addition to version, eg.::
@@ -834,16 +882,24 @@ def list_pkgs(versions_as_list=False, **kwargs):
     if attr is not None:
         attr = salt.utils.args.split_input(attr)
 
-    contextkey = "pkg.list_pkgs"
+    includes = includes if includes else []
+
+    # Results can be different if a different root or a different
+    # inclusion types are passed
+    contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
 
     if contextkey not in __context__:
         ret = {}
-        cmd = [
-            "rpm",
-            "-qa",
-            "--queryformat",
-            salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
-        ]
+        cmd = ["rpm"]
+        if root:
+            cmd.extend(["--root", root])
+        cmd.extend(
+            [
+                "-qa",
+                "--queryformat",
+                salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
+            ]
+        )
         output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
         for line in output.splitlines():
             pkginfo = salt.utils.pkg.rpm.parse_pkginfo(
@@ -875,6 +931,42 @@ def list_pkgs(versions_as_list=False, **kwargs):
                 continue
             _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
 
+        for include in includes:
+            if include == "product":
+                products = list_products(all=False, root=root)
+                for product in products:
+                    extended_name = "{}:{}".format(include, product["name"])
+                    _ret[extended_name] = [
+                        {
+                            "epoch": product["epoch"],
+                            "version": product["version"],
+                            "release": product["release"],
+                            "arch": product["arch"],
+                            "install_date": None,
+                            "install_date_time_t": None,
+                        }
+                    ]
+            if include in ("pattern", "patch"):
+                if include == "pattern":
+                    elements = list_installed_patterns(root=root)
+                elif include == "patch":
+                    elements = list_installed_patches(root=root)
+                else:
+                    elements = []
+                for element in elements:
+                    extended_name = "{}:{}".format(include, element)
+                    info = info_available(extended_name, refresh=False, root=root)
+                    _ret[extended_name] = [
+                        {
+                            "epoch": None,
+                            "version": info[element]["version"],
+                            "release": None,
+                            "arch": info[element]["arch"],
+                            "install_date": None,
+                            "install_date_time_t": None,
+                        }
+                    ]
+
         __context__[contextkey] = _ret
 
     return __salt__["pkg_resource.format_pkg_list"](
@@ -925,6 +1017,9 @@ def list_repo_pkgs(*args, **kwargs):
         When ``True``, the return data for each package will be organized by
         repository.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -956,8 +1051,11 @@ def _is_match(pkgname):
                 return True
         return False
 
-    for node in __zypper__.xml.call("se", "-s", *targets).getElementsByTagName(
-        "solvable"
+    root = kwargs.get("root") or None
+    for node in (
+        __zypper__(root=root)
+        .xml.call("se", "-s", *targets)
+        .getElementsByTagName("solvable")
     ):
         pkginfo = dict(node.attributes.items())
         try:
@@ -998,25 +1096,33 @@ def _is_match(pkgname):
         return byrepo_ret
 
 
-def _get_configured_repos():
+def _get_configured_repos(root=None):
     """
     Get all the info about repositories from the configurations.
     """
 
+    repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
     repos_cfg = configparser.ConfigParser()
-    repos_cfg.read(
-        [REPOS + "/" + fname for fname in os.listdir(REPOS) if fname.endswith(".repo")]
-    )
+    if os.path.exists(repos):
+        repos_cfg.read(
+            [
+                repos + "/" + fname
+                for fname in os.listdir(repos)
+                if fname.endswith(".repo")
+            ]
+        )
+    else:
+        log.warning("Repositories not found in {}".format(repos))
 
     return repos_cfg
 
 
-def _get_repo_info(alias, repos_cfg=None):
+def _get_repo_info(alias, repos_cfg=None, root=None):
     """
     Get one repo meta-data.
     """
     try:
-        meta = dict((repos_cfg or _get_configured_repos()).items(alias))
+        meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
         meta["alias"] = alias
         for key, val in six.iteritems(meta):
             if val in ["0", "1"]:
@@ -1028,51 +1134,62 @@ def _get_repo_info(alias, repos_cfg=None):
         return {}
 
 
-def get_repo(repo, **kwargs):  # pylint: disable=unused-argument
+def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
     """
     Display a repo.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
 
         salt '*' pkg.get_repo alias
     """
-    return _get_repo_info(repo)
+    return _get_repo_info(repo, root=root)
 
 
-def list_repos():
+def list_repos(root=None, **kwargs):
     """
     Lists all repos.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
 
        salt '*' pkg.list_repos
     """
-    repos_cfg = _get_configured_repos()
+    repos_cfg = _get_configured_repos(root=root)
     all_repos = {}
     for alias in repos_cfg.sections():
-        all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg)
+        all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
 
     return all_repos
 
 
-def del_repo(repo):
+def del_repo(repo, root=None):
     """
     Delete a repo.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
 
         salt '*' pkg.del_repo alias
     """
-    repos_cfg = _get_configured_repos()
+    repos_cfg = _get_configured_repos(root=root)
     for alias in repos_cfg.sections():
         if alias == repo:
-            doc = __zypper__.xml.call("rr", "--loose-auth", "--loose-query", alias)
+            doc = __zypper__(root=root).xml.call(
+                "rr", "--loose-auth", "--loose-query", alias
+            )
             msg = doc.getElementsByTagName("message")
             if doc.getElementsByTagName("progress") and msg:
                 return {
@@ -1111,6 +1228,9 @@ def mod_repo(repo, **kwargs):
         If set to True, automatically trust and import public GPG key for
         the repository.
 
+    root
+        operate on a different root directory.
+
     Key/Value pairs may also be removed from a repo's configuration by setting
     a key to a blank value. Bear in mind that a name cannot be deleted, and a
     URL can only be deleted if a ``mirrorlist`` is specified (or vice versa).
@@ -1123,7 +1243,8 @@ def mod_repo(repo, **kwargs):
         salt '*' pkg.mod_repo alias url= mirrorlist=http://host.com/
     """
 
-    repos_cfg = _get_configured_repos()
+    root = kwargs.get("root") or None
+    repos_cfg = _get_configured_repos(root=root)
     added = False
 
     # An attempt to add new one?
@@ -1143,7 +1264,7 @@ def mod_repo(repo, **kwargs):
 
         # Is there already such repo under different alias?
         for alias in repos_cfg.sections():
-            repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg)
+            repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
 
             # Complete user URL, in case it is not
             new_url = _urlparse(url)
@@ -1164,10 +1285,10 @@ def mod_repo(repo, **kwargs):
                 )
 
         # Add new repo
-        __zypper__.xml.call("ar", url, repo)
+        __zypper__(root=root).xml.call("ar", url, repo)
 
         # Verify the repository has been added
-        repos_cfg = _get_configured_repos()
+        repos_cfg = _get_configured_repos(root=root)
         if repo not in repos_cfg.sections():
             raise CommandExecutionError(
                 "Failed add new repository '{0}' for unspecified reason. "
@@ -1175,7 +1296,7 @@ def mod_repo(repo, **kwargs):
             )
         added = True
 
-    repo_info = _get_repo_info(repo)
+    repo_info = _get_repo_info(repo, root=root)
     if (
         not added
         and "baseurl" in kwargs
@@ -1185,8 +1306,8 @@ def mod_repo(repo, **kwargs):
         # we need to remove the repository and add it again with the new baseurl
         repo_info.update(kwargs)
         repo_info.setdefault("cache", False)
-        del_repo(repo)
-        return mod_repo(repo, **repo_info)
+        del_repo(repo, root=root)
+        return mod_repo(repo, root=root, **repo_info)
 
     # Modify added or existing repo according to the options
     cmd_opt = []
@@ -1219,7 +1340,7 @@ def mod_repo(repo, **kwargs):
 
     if cmd_opt:
         cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
-        __zypper__.refreshable.xml.call(*cmd_opt)
+        __zypper__(root=root).refreshable.xml.call(*cmd_opt)
 
     comment = None
     if call_refresh:
@@ -1227,18 +1348,18 @@ def mod_repo(repo, **kwargs):
         # --gpg-auto-import-keys is not doing anything
         # so we need to specifically refresh here with --gpg-auto-import-keys
         refresh_opts = global_cmd_opt + ["refresh"] + [repo]
-        __zypper__.xml.call(*refresh_opts)
+        __zypper__(root=root).xml.call(*refresh_opts)
     elif not added and not cmd_opt:
         comment = "Specified arguments did not result in modification of repo"
 
-    repo = get_repo(repo)
+    repo = get_repo(repo, root=root)
     if comment:
         repo["comment"] = comment
 
     return repo
 
 
-def refresh_db(force=None):
+def refresh_db(force=None, root=None):
     """
     Trigger a repository refresh by calling ``zypper refresh``. Refresh will run
     with ``--force`` if the "force=True" flag is passed on the CLI or
@@ -1249,6 +1370,9 @@ def refresh_db(force=None):
 
         {'<database name>': Bool}
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -1270,7 +1394,7 @@ def refresh_db(force=None):
         force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
     if force:
         refresh_opts.append("--force")
-    out = __zypper__.refreshable.call(*refresh_opts)
+    out = __zypper__(root=root).refreshable.call(*refresh_opts)
 
     for line in out.splitlines():
         if not line:
@@ -1289,6 +1413,11 @@ def refresh_db(force=None):
     return ret
 
 
+def _find_types(pkgs):
+    """Form a package names list, find prefixes of packages types."""
+    return sorted({pkg.split(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
+
+
 def install(
     name=None,
     refresh=False,
@@ -1299,6 +1428,8 @@ def install(
     skip_verify=False,
     version=None,
     ignore_repo_failure=False,
+    no_recommends=False,
+    root=None,
     **kwargs
 ):
     """
@@ -1388,6 +1519,12 @@ def install(
         Zypper returns error code 106 if one of the repositories are not available for various reasons.
         In case to set strict check, this parameter needs to be set to True. Default: False.
 
+    no_recommends
+        Do not install recommended packages, only required ones.
+
+    root
+        operate on a different root directory.
+
     diff_attr:
         If a list of package attributes is specified, returned value will
         contain them, eg.::
@@ -1427,7 +1564,7 @@ def install(
                 'arch': '<new-arch>'}}}
     """
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     try:
         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
@@ -1439,7 +1576,7 @@ def install(
     if pkg_params is None or len(pkg_params) == 0:
         return {}
 
-    version_num = Wildcard(__zypper__)(name, version)
+    version_num = Wildcard(__zypper__(root=root))(name, version)
 
     if version_num:
         if pkgs is None and sources is None:
@@ -1465,19 +1602,31 @@ def install(
                 targets.append(target)
     elif pkg_type == "advisory":
         targets = []
-        cur_patches = list_patches()
+        cur_patches = list_patches(root=root)
         for advisory_id in pkg_params:
             if advisory_id not in cur_patches:
                 raise CommandExecutionError(
                     'Advisory id "{0}" not found'.format(advisory_id)
                 )
             else:
+                # If we add here the `patch:` prefix, the
+                # `_find_types` helper will take the patches into the
+                # list of packages. Usually this is the correct thing
+                # to do, but we can break software the depends on the
+                # old behaviour.
                 targets.append(advisory_id)
     else:
         targets = pkg_params
 
     diff_attr = kwargs.get("diff_attr")
-    old = list_pkgs(attr=diff_attr) if not downloadonly else list_downloaded()
+
+    includes = _find_types(targets)
+    old = (
+        list_pkgs(attr=diff_attr, root=root, includes=includes)
+        if not downloadonly
+        else list_downloaded(root)
+    )
+
     downgrades = []
     if fromrepo:
         fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
@@ -1498,10 +1647,20 @@ def install(
         cmd_install.append("--download-only")
     if fromrepo:
         cmd_install.extend(fromrepoopt)
+    if no_recommends:
+        cmd_install.append("--no-recommends")
 
     errors = []
+
+    # If the type is 'advisory', we manually add the 'patch:'
+    # prefix. This kind of package will not appear in pkg_list in this
+    # way.
+    #
+    # Note that this enable a different mechanism to install a patch;
+    # if the name of the package is already prefixed with 'patch:' we
+    # can avoid listing them in the `advisory_ids` field.
     if pkg_type == "advisory":
-        targets = ["patch:{0}".format(t) for t in targets]
+        targets = ["patch:{}".format(t) for t in targets]
 
     # Split the targets into batches of 500 packages each, so that
     # the maximal length of the command line is not broken
@@ -1510,7 +1669,11 @@ def install(
         cmd = cmd_install + targets[:500]
         targets = targets[500:]
         for line in (
-            __zypper__(no_repo_failure=ignore_repo_failure, systemd_scope=systemd_scope)
+            __zypper__(
+                no_repo_failure=ignore_repo_failure,
+                systemd_scope=systemd_scope,
+                root=root,
+            )
             .call(*cmd)
             .splitlines()
         ):
@@ -1523,12 +1686,21 @@ def install(
     while downgrades:
         cmd = cmd_install + ["--force"] + downgrades[:500]
         downgrades = downgrades[500:]
-        __zypper__(no_repo_failure=ignore_repo_failure).call(*cmd)
+        __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
 
     _clean_cache()
-    new = list_pkgs(attr=diff_attr) if not downloadonly else list_downloaded()
+    new = (
+        list_pkgs(attr=diff_attr, root=root, includes=includes)
+        if not downloadonly
+        else list_downloaded(root)
+    )
     ret = salt.utils.data.compare_dicts(old, new)
 
+    # If something else from packages are included in the search,
+    # better clean the cache.
+    if includes:
+        _clean_cache()
+
     if errors:
         raise CommandExecutionError(
             "Problem encountered {0} package(s)".format(
@@ -1547,6 +1719,8 @@ def upgrade(
     fromrepo=None,
     novendorchange=False,
     skip_verify=False,
+    no_recommends=False,
+    root=None,
     **kwargs
 ):  # pylint: disable=unused-argument
     """
@@ -1587,6 +1761,12 @@ def upgrade(
     skip_verify
         Skip the GPG verification check (e.g., ``--no-gpg-checks``)
 
+    no_recommends
+        Do not install recommended packages, only required ones.
+
+    root
+        Operate on a different root directory.
+
     Returns a dictionary containing the changes:
 
     .. code-block:: python
@@ -1611,7 +1791,7 @@ def upgrade(
         cmd_update.insert(0, "--no-gpg-checks")
 
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     if dryrun:
         cmd_update.append("--dry-run")
@@ -1634,18 +1814,22 @@ def upgrade(
                     "Disabling vendor changes is not supported on this Zypper version"
                 )
 
+        if no_recommends:
+            cmd_update.append("--no-recommends")
+            log.info("Disabling recommendations")
+
         if dryrun:
             # Creates a solver test case for debugging.
             log.info("Executing debugsolver and performing a dry-run dist-upgrade")
-            __zypper__(systemd_scope=_systemd_scope()).noraise.call(
+            __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
                 *cmd_update + ["--debug-solver"]
             )
 
-    old = list_pkgs()
+    old = list_pkgs(root=root)
 
-    __zypper__(systemd_scope=_systemd_scope()).noraise.call(*cmd_update)
+    __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
     _clean_cache()
-    new = list_pkgs()
+    new = list_pkgs(root=root)
     ret = salt.utils.data.compare_dicts(old, new)
 
     if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
@@ -1666,7 +1850,7 @@ def upgrade(
     return ret
 
 
-def _uninstall(name=None, pkgs=None):
+def _uninstall(name=None, pkgs=None, root=None):
     """
     Remove and purge do identical things but with different Zypper commands,
     this function performs the common logic.
@@ -1676,7 +1860,8 @@ def _uninstall(name=None, pkgs=None):
     except MinionError as exc:
         raise CommandExecutionError(exc)
 
-    old = list_pkgs()
+    includes = _find_types(pkg_params.keys())
+    old = list_pkgs(root=root, includes=includes)
     targets = []
     for target in pkg_params:
         # Check if package version set to be removed is actually installed:
@@ -1692,11 +1877,14 @@ def _uninstall(name=None, pkgs=None):
 
     errors = []
     while targets:
-        __zypper__(systemd_scope=systemd_scope).call("remove", *targets[:500])
+        __zypper__(systemd_scope=systemd_scope, root=root).call(
+            "remove", *targets[:500]
+        )
         targets = targets[500:]
 
     _clean_cache()
-    ret = salt.utils.data.compare_dicts(old, list_pkgs())
+    new = list_pkgs(root=root, includes=includes)
+    ret = salt.utils.data.compare_dicts(old, new)
 
     if errors:
         raise CommandExecutionError(
@@ -1734,7 +1922,9 @@ def normalize_name(name):
     return name
 
 
-def remove(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
+def remove(
+    name=None, pkgs=None, root=None, **kwargs
+):  # pylint: disable=unused-argument
     """
     .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
         On minions running systemd>=205, `systemd-run(1)`_ is now used to
@@ -1762,6 +1952,9 @@ def remove(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
         A list of packages to delete. Must be passed as a python list. The
         ``name`` parameter will be ignored if this option is passed.
 
+    root
+        Operate on a different root directory.
+
     .. versionadded:: 0.16.0
 
 
@@ -1775,10 +1968,10 @@ def remove(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
         salt '*' pkg.remove <package1>,<package2>,<package3>
         salt '*' pkg.remove pkgs='["foo", "bar"]'
     """
-    return _uninstall(name=name, pkgs=pkgs)
+    return _uninstall(name=name, pkgs=pkgs, root=root)
 
 
-def purge(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
+def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
     """
     .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
         On minions running systemd>=205, `systemd-run(1)`_ is now used to
@@ -1807,6 +2000,9 @@ def purge(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
         A list of packages to delete. Must be passed as a python list. The
         ``name`` parameter will be ignored if this option is passed.
 
+    root
+        Operate on a different root directory.
+
     .. versionadded:: 0.16.0
 
 
@@ -1820,13 +2016,16 @@ def purge(name=None, pkgs=None, **kwargs):  # pylint: disable=unused-argument
         salt '*' pkg.purge <package1>,<package2>,<package3>
         salt '*' pkg.purge pkgs='["foo", "bar"]'
     """
-    return _uninstall(name=name, pkgs=pkgs)
+    return _uninstall(name=name, pkgs=pkgs, root=root)
 
 
-def list_locks():
+def list_locks(root=None):
     """
     List current package locks.
 
+    root
+        operate on a different root directory.
+
     Return a dict containing the locked package with attributes::
 
         {'<package>': {'case_sensitive': '<case_sensitive>',
@@ -1840,8 +2039,9 @@ def list_locks():
         salt '*' pkg.list_locks
     """
     locks = {}
-    if os.path.exists(LOCKS):
-        with salt.utils.files.fopen(LOCKS) as fhr:
+    _locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
+    try:
+        with salt.utils.files.fopen(_locks) as fhr:
             items = salt.utils.stringutils.to_unicode(fhr.read()).split("\n\n")
             for meta in [item.split("\n") for item in items]:
                 lock = {}
@@ -1852,15 +2052,22 @@ def list_locks():
                         )
                 if lock.get("solvable_name"):
                     locks[lock.pop("solvable_name")] = lock
+    except IOError:
+        pass
+    except Exception:  # pylint: disable=broad-except
+        log.warning("Detected a problem when accessing {}".format(_locks))
 
     return locks
 
 
-def clean_locks():
+def clean_locks(root=None):
     """
     Remove unused locks that do not currently (with regard to repositories
     used) lock any package.
 
+    root
+        Operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -1869,10 +2076,11 @@ def clean_locks():
     """
     LCK = "removed"
     out = {LCK: 0}
-    if not os.path.exists("/etc/zypp/locks"):
+    locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
+    if not os.path.exists(locks):
         return out
 
-    for node in __zypper__.xml.call("cl").getElementsByTagName("message"):
+    for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
         text = node.childNodes[0].nodeValue.lower()
         if text.startswith(LCK):
             out[LCK] = text.split(" ")[1]
@@ -1881,10 +2089,13 @@ def clean_locks():
     return out
 
 
-def remove_lock(packages, **kwargs):  # pylint: disable=unused-argument
+def remove_lock(packages, root=None, **kwargs):  # pylint: disable=unused-argument
     """
     Remove specified package lock.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -1894,7 +2105,7 @@ def remove_lock(packages, **kwargs):  # pylint: disable=unused-argument
         salt '*' pkg.remove_lock pkgs='["foo", "bar"]'
     """
 
-    locks = list_locks()
+    locks = list_locks(root)
     try:
         packages = list(__salt__["pkg_resource.parse_targets"](packages)[0].keys())
     except MinionError as exc:
@@ -1909,15 +2120,18 @@ def remove_lock(packages, **kwargs):  # pylint: disable=unused-argument
             missing.append(pkg)
 
     if removed:
-        __zypper__.call("rl", *removed)
+        __zypper__(root=root).call("rl", *removed)
 
     return {"removed": len(removed), "not_found": missing}
 
 
-def add_lock(packages, **kwargs):  # pylint: disable=unused-argument
+def add_lock(packages, root=None, **kwargs):  # pylint: disable=unused-argument
     """
     Add a package lock. Specify packages to lock by exact name.
 
+    root
+        operate on a different root directory.
+
     CLI Example:
 
     .. code-block:: bash
@@ -1926,7 +2140,7 @@ def add_lock(packages, **kwargs):  # pylint: disable=unused-argument
         salt '*' pkg.add_lock <package1>,<package2>,<package3>
         salt '*' pkg.add_lock pkgs='["foo", "bar"]'
     """
-    locks = list_locks()
+    locks = list_locks(root)
     added = []
     try:
         packages = list(__salt__["pkg_resource.parse_targets"](packages)[0].keys())
@@ -1938,7 +2152,7 @@ def add_lock(packages, **kwargs):  # pylint: disable=unused-argument
             added.append(pkg)
 
     if added:
-        __zypper__.call("al", *added)
+        __zypper__(root=root).call("al", *added)
 
     return {"added": len(added), "packages": added}
 
@@ -1948,7 +2162,9 @@ def verify(*names, **kwargs):
     Runs an rpm -Va on a system, and returns the results in a dict
 
     Files with an attribute of config, doc, ghost, license or readme in the
-    package header can be ignored using the ``ignore_types`` keyword argument
+    package header can be ignored using the ``ignore_types`` keyword argument.
+
+    The root parameter can also be passed via the keyword argument.
 
     CLI Example:
 
@@ -1962,12 +2178,14 @@ def verify(*names, **kwargs):
     return __salt__["lowpkg.verify"](*names, **kwargs)
 
 
-def file_list(*packages):
+def file_list(*packages, **kwargs):
     """
     List the files that belong to a package. Not specifying any packages will
     return a list of *every* file on the system's rpm database (not generally
     recommended).
 
+    The root parameter can also be passed via the keyword argument.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -1976,15 +2194,17 @@ def file_list(*packages):
         salt '*' pkg.file_list httpd postfix
         salt '*' pkg.file_list
     """
-    return __salt__["lowpkg.file_list"](*packages)
+    return __salt__["lowpkg.file_list"](*packages, **kwargs)
 
 
-def file_dict(*packages):
+def file_dict(*packages, **kwargs):
     """
     List the files that belong to a package, grouped by package. Not
     specifying any packages will return a list of *every* file on the system's
     rpm database (not generally recommended).
 
+    The root parameter can also be passed via the keyword argument.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -1993,7 +2213,7 @@ def file_dict(*packages):
         salt '*' pkg.file_list httpd postfix
         salt '*' pkg.file_list
     """
-    return __salt__["lowpkg.file_dict"](*packages)
+    return __salt__["lowpkg.file_dict"](*packages, **kwargs)
 
 
 def modified(*packages, **flags):
@@ -2032,6 +2252,9 @@ def modified(*packages, **flags):
     capabilities
         Include only files where capabilities differ or not. Note: supported only on newer RPM versions.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -2045,7 +2268,7 @@ def modified(*packages, **flags):
     return __salt__["lowpkg.modified"](*packages, **flags)
 
 
-def owner(*paths):
+def owner(*paths, **kwargs):
     """
     Return the name of the package that owns the file. Multiple file paths can
     be passed. If a single path is passed, a string will be returned,
@@ -2055,6 +2278,8 @@ def owner(*paths):
     If the file is not owned by a package, or is not present on the minion,
     then an empty string will be returned for that path.
 
+    The root parameter can also be passed via the keyword argument.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -2062,28 +2287,74 @@ def owner(*paths):
         salt '*' pkg.owner /usr/bin/apachectl
         salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf
     """
-    return __salt__["lowpkg.owner"](*paths)
+    return __salt__["lowpkg.owner"](*paths, **kwargs)
 
 
-def _get_patterns(installed_only=None):
-    """
-    List all known patterns in repos.
-    """
+def _get_visible_patterns(root=None):
+    """Get all available patterns in the repo that are visible."""
     patterns = {}
-    for element in __zypper__.nolock.xml.call(
-        "se", "-t", "pattern"
-    ).getElementsByTagName("solvable"):
+    search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
+    for element in search_patterns.getElementsByTagName("solvable"):
         installed = element.getAttribute("status") == "installed"
-        if (installed_only and installed) or not installed_only:
-            patterns[element.getAttribute("name")] = {
-                "installed": installed,
-                "summary": element.getAttribute("summary"),
+        patterns[element.getAttribute("name")] = {
+            "installed": installed,
+            "summary": element.getAttribute("summary"),
+        }
+    return patterns
+
+
+def _get_installed_patterns(root=None):
+    """
+    List all installed patterns.
+    """
+    # Some patterns are non visible (`pattern-visible()` capability is
+    # not set), so they cannot be found via a normal `zypper se -t
+    # pattern`.
+    #
+    # Also patterns are not directly searchable in the local rpmdb.
+    #
+    # The proposed solution is, first search all the packages that
+    # containst the 'pattern()' capability, and deduce the name of the
+    # pattern from this capability.
+    #
+    # For example:
+    #
+    #   'pattern() = base' -> 'base'
+    #   'pattern() = microos_defaults' -> 'microos_defaults'
+
+    def _pattern_name(capability):
+        """Return from a suitable capability the pattern name."""
+        return capability.split("=")[-1].strip()
+
+    cmd = ["rpm"]
+    if root:
+        cmd.extend(["--root", root])
+    cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
+    # If no `pattern()`s are found, RPM returns `1`, but for us is not
+    # a real error.
+    output = __salt__["cmd.run"](cmd, ignore_retcode=True)
+
+    installed_patterns = [
+        _pattern_name(line)
+        for line in output.splitlines()
+        if line.startswith("pattern() = ")
+    ]
+
+    patterns = {
+        k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
+    }
+
+    for pattern in installed_patterns:
+        if pattern not in patterns:
+            patterns[pattern] = {
+                "installed": True,
+                "summary": "Non-visible pattern",
             }
 
     return patterns
 
 
-def list_patterns(refresh=False):
+def list_patterns(refresh=False, root=None):
     """
     List all known patterns from available repos.
 
@@ -2092,6 +2363,9 @@ def list_patterns(refresh=False):
         If set to False (default) it depends on zypper if a refresh is
         executed.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -2099,27 +2373,30 @@ def list_patterns(refresh=False):
         salt '*' pkg.list_patterns
     """
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
-    return _get_patterns()
+    return _get_visible_patterns(root=root)
 
 
-def list_installed_patterns():
+def list_installed_patterns(root=None):
     """
     List installed patterns on the system.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
 
         salt '*' pkg.list_installed_patterns
     """
-    return _get_patterns(installed_only=True)
+    return _get_installed_patterns(root=root)
 
 
 def search(criteria, refresh=False, **kwargs):
     """
-    List known packags, available to the system.
+    List known packages, available to the system.
 
     refresh
         force a refresh if set to True.
@@ -2167,6 +2444,9 @@ def search(criteria, refresh=False, **kwargs):
     details (bool)
         Show version and repository
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -2187,8 +2467,11 @@ def search(criteria, refresh=False, **kwargs):
         "not_installed_only": "-u",
         "details": "--details",
     }
+
+    root = kwargs.get("root", None)
+
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     cmd = ["search"]
     if kwargs.get("match") == "exact":
@@ -2203,8 +2486,10 @@ def search(criteria, refresh=False, **kwargs):
             cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
 
     cmd.append(criteria)
-    solvables = __zypper__.nolock.noraise.xml.call(*cmd).getElementsByTagName(
-        "solvable"
+    solvables = (
+        __zypper__(root=root)
+        .nolock.noraise.xml.call(*cmd)
+        .getElementsByTagName("solvable")
     )
     if not solvables:
         raise CommandExecutionError("No packages found matching '{0}'".format(criteria))
@@ -2232,7 +2517,7 @@ def _get_first_aggregate_text(node_list):
     return "\n".join(out)
 
 
-def list_products(all=False, refresh=False):
+def list_products(all=False, refresh=False, root=None):
     """
     List all available or installed SUSE products.
 
@@ -2244,6 +2529,9 @@ def list_products(all=False, refresh=False):
         If set to False (default) it depends on zypper if a refresh is
         executed.
 
+    root
+        operate on a different root directory.
+
     Includes handling for OEM products, which read the OEM productline file
     and overwrite the release value.
 
@@ -2255,10 +2543,12 @@ def list_products(all=False, refresh=False):
         salt '*' pkg.list_products all=True
     """
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     ret = list()
     OEM_PATH = "/var/lib/suseRegister/OEM"
+    if root:
+        OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
     cmd = list()
     if not all:
         cmd.append("--disable-repositories")
@@ -2266,7 +2556,9 @@ def list_products(all=False, refresh=False):
     if not all:
         cmd.append("-i")
 
-    product_list = __zypper__.nolock.xml.call(*cmd).getElementsByTagName("product-list")
+    product_list = (
+        __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
+    )
     if not product_list:
         return ret  # No products found
 
@@ -2313,6 +2605,9 @@ def download(*packages, **kwargs):
         If set to False (default) it depends on zypper if a refresh is
         executed.
 
+    root
+        operate on a different root directory.
+
     CLI example:
 
     .. code-block:: bash
@@ -2323,13 +2618,17 @@ def download(*packages, **kwargs):
     if not packages:
         raise SaltInvocationError("No packages specified")
 
+    root = kwargs.get("root", None)
+
     refresh = kwargs.get("refresh", False)
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     pkg_ret = {}
-    for dld_result in __zypper__.xml.call("download", *packages).getElementsByTagName(
-        "download-result"
+    for dld_result in (
+        __zypper__(root=root)
+        .xml.call("download", *packages)
+        .getElementsByTagName("download-result")
     ):
         repo = dld_result.getElementsByTagName("repository")[0]
         path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
@@ -2339,7 +2638,7 @@ def download(*packages, **kwargs):
             "path": path,
         }
         key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
-        if __salt__["lowpkg.checksum"](pkg_info["path"]):
+        if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
             pkg_ret[key] = pkg_info
 
     if pkg_ret:
@@ -2357,12 +2656,15 @@ def download(*packages, **kwargs):
     )
 
 
-def list_downloaded(**kwargs):
+def list_downloaded(root=None, **kwargs):
     """
     .. versionadded:: 2017.7.0
 
     List prefetched packages downloaded by Zypper in the local disk.
 
+    root
+        operate on a different root directory.
+
     CLI example:
 
     .. code-block:: bash
@@ -2370,6 +2672,8 @@ def list_downloaded(**kwargs):
         salt '*' pkg.list_downloaded
     """
     CACHE_DIR = "/var/cache/zypp/packages/"
+    if root:
+        CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
 
     ret = {}
     for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
@@ -2388,12 +2692,14 @@ def list_downloaded(**kwargs):
     return ret
 
 
-def diff(*paths):
+def diff(*paths, **kwargs):
     """
     Return a formatted diff between current files and original in a package.
     NOTE: this function includes all files (configuration and not), but does
     not work on binary content.
 
+    The root parameter can also be passed via the keyword argument.
+
     :param path: Full path to the installed file
     :return: Difference string or raises and exception if examined file is binary.
 
@@ -2407,7 +2713,7 @@ def diff(*paths):
 
     pkg_to_paths = {}
     for pth in paths:
-        pth_pkg = __salt__["lowpkg.owner"](pth)
+        pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
         if not pth_pkg:
             ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
         else:
@@ -2416,7 +2722,7 @@ def diff(*paths):
             pkg_to_paths[pth_pkg].append(pth)
 
     if pkg_to_paths:
-        local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys())
+        local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
         for pkg, files in six.iteritems(pkg_to_paths):
             for path in files:
                 ret[path] = (
@@ -2427,13 +2733,15 @@ def diff(*paths):
     return ret
 
 
-def _get_patches(installed_only=False):
+def _get_patches(installed_only=False, root=None):
     """
     List all known patches in repos.
     """
     patches = {}
-    for element in __zypper__.nolock.xml.call("se", "-t", "patch").getElementsByTagName(
-        "solvable"
+    for element in (
+        __zypper__(root=root)
+        .nolock.xml.call("se", "-t", "patch")
+        .getElementsByTagName("solvable")
     ):
         installed = element.getAttribute("status") == "installed"
         if (installed_only and installed) or not installed_only:
@@ -2445,7 +2753,7 @@ def _get_patches(installed_only=False):
     return patches
 
 
-def list_patches(refresh=False):
+def list_patches(refresh=False, root=None, **kwargs):
     """
     .. versionadded:: 2017.7.0
 
@@ -2456,6 +2764,9 @@ def list_patches(refresh=False):
         If set to False (default) it depends on zypper if a refresh is
         executed.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -2463,33 +2774,39 @@ def list_patches(refresh=False):
         salt '*' pkg.list_patches
     """
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
-    return _get_patches()
+    return _get_patches(root=root)
 
 
-def list_installed_patches():
+def list_installed_patches(root=None, **kwargs):
     """
     .. versionadded:: 2017.7.0
 
     List installed advisory patches on the system.
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
 
         salt '*' pkg.list_installed_patches
     """
-    return _get_patches(installed_only=True)
+    return _get_patches(installed_only=True, root=root)
 
 
-def list_provides(**kwargs):
+def list_provides(root=None, **kwargs):
     """
     .. versionadded:: 2018.3.0
 
     List package provides of installed packages as a dict.
     {'<provided_name>': ['<package_name>', '<package_name>', ...]}
 
+    root
+        operate on a different root directory.
+
     CLI Examples:
 
     .. code-block:: bash
@@ -2498,7 +2815,10 @@ def list_provides(**kwargs):
     """
     ret = __context__.get("pkg.list_provides")
     if not ret:
-        cmd = ["rpm", "-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"]
+        cmd = ["rpm"]
+        if root:
+            cmd.extend(["--root", root])
+        cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
         ret = dict()
         for line in __salt__["cmd.run"](
             cmd, output_loglevel="trace", python_shell=False
@@ -2516,7 +2836,7 @@ def list_provides(**kwargs):
     return ret
 
 
-def resolve_capabilities(pkgs, refresh, **kwargs):
+def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
     """
     .. versionadded:: 2018.3.0
 
@@ -2530,6 +2850,9 @@ def resolve_capabilities(pkgs, refresh, **kwargs):
         If set to False (default) it depends on zypper if a refresh is
         executed.
 
+    root
+        operate on a different root directory.
+
     resolve_capabilities
         If this option is set to True the input will be checked if
         a package with this name exists. If not, this function will
@@ -2545,7 +2868,7 @@ def resolve_capabilities(pkgs, refresh, **kwargs):
         salt '*' pkg.resolve_capabilities resolve_capabilities=True w3m_ssl
     """
     if refresh:
-        refresh_db()
+        refresh_db(root)
 
     ret = list()
     for pkg in pkgs:
@@ -2558,12 +2881,12 @@ def resolve_capabilities(pkgs, refresh, **kwargs):
 
         if kwargs.get("resolve_capabilities", False):
             try:
-                search(name, match="exact")
+                search(name, root=root, match="exact")
             except CommandExecutionError:
                 # no package this such a name found
                 # search for a package which provides this name
                 try:
-                    result = search(name, provides=True, match="exact")
+                    result = search(name, root=root, provides=True, match="exact")
                     if len(result) == 1:
                         name = next(iter(result.keys()))
                     elif len(result) > 1:
diff --git a/salt/states/pkg.py b/salt/states/pkg.py
index e3729305f7951..23f46cabdc0b1 100644
--- a/salt/states/pkg.py
+++ b/salt/states/pkg.py
@@ -265,14 +265,18 @@ def _fulfills_version_spec(versions, oper, desired_version, ignore_epoch=None):
     return False
 
 
-def _find_unpurge_targets(desired):
+def _find_unpurge_targets(desired, **kwargs):
     """
     Find packages which are marked to be purged but can't yet be removed
     because they are dependencies for other installed packages. These are the
     packages which will need to be 'unpurged' because they are part of
     pkg.installed states. This really just applies to Debian-based Linuxes.
     """
-    return [x for x in desired if x in __salt__["pkg.list_pkgs"](purge_desired=True)]
+    return [
+        x
+        for x in desired
+        if x in __salt__["pkg.list_pkgs"](purge_desired=True, **kwargs)
+    ]
 
 
 def _find_download_targets(
@@ -288,7 +292,7 @@ def _find_download_targets(
     Inspect the arguments to pkg.downloaded and discover what packages need to
     be downloaded. Return a dict of packages to download.
     """
-    cur_pkgs = __salt__["pkg.list_downloaded"]()
+    cur_pkgs = __salt__["pkg.list_downloaded"](**kwargs)
     if pkgs:
         # pylint: disable=not-callable
         to_download = _repack_pkgs(pkgs, normalize=normalize)
@@ -410,7 +414,7 @@ def _find_advisory_targets(name=None, advisory_ids=None, **kwargs):
     Inspect the arguments to pkg.patch_installed and discover what advisory
     patches need to be installed. Return a dict of advisory patches to install.
     """
-    cur_patches = __salt__["pkg.list_installed_patches"]()
+    cur_patches = __salt__["pkg.list_installed_patches"](**kwargs)
     if advisory_ids:
         to_download = advisory_ids
     else:
@@ -619,7 +623,7 @@ def _find_install_targets(
                 "minion log.".format("pkgs" if pkgs else "sources"),
             }
 
-        to_unpurge = _find_unpurge_targets(desired)
+        to_unpurge = _find_unpurge_targets(desired, **kwargs)
     else:
         if salt.utils.platform.is_windows():
             # pylint: disable=not-callable
@@ -646,7 +650,7 @@ def _find_install_targets(
         else:
             desired = {name: version}
 
-        to_unpurge = _find_unpurge_targets(desired)
+        to_unpurge = _find_unpurge_targets(desired, **kwargs)
 
         # FreeBSD pkg supports `openjdk` and `java/openjdk7` package names
         origin = bool(re.search("/", name))
@@ -819,6 +823,7 @@ def _find_install_targets(
                             package_name,
                             ignore_types=ignore_types,
                             verify_options=verify_options,
+                            **kwargs
                         )
                     except (CommandExecutionError, SaltInvocationError) as exc:
                         failed_verify = exc.strerror
@@ -852,6 +857,7 @@ def _find_install_targets(
                             package_name,
                             ignore_types=ignore_types,
                             verify_options=verify_options,
+                            **kwargs
                         )
                     except (CommandExecutionError, SaltInvocationError) as exc:
                         failed_verify = exc.strerror
@@ -2094,7 +2100,10 @@ def installed(
             # No need to wrap this in a try/except because we would already
             # have caught invalid arguments earlier.
             verify_result = __salt__["pkg.verify"](
-                reinstall_pkg, ignore_types=ignore_types, verify_options=verify_options
+                reinstall_pkg,
+                ignore_types=ignore_types,
+                verify_options=verify_options,
+                **kwargs
             )
             if verify_result:
                 failed.append(reinstall_pkg)
@@ -2301,7 +2310,7 @@ def downloaded(
             )
         return ret
 
-    new_pkgs = __salt__["pkg.list_downloaded"]()
+    new_pkgs = __salt__["pkg.list_downloaded"](**kwargs)
     _ok, failed = _verify_install(targets, new_pkgs, ignore_epoch=ignore_epoch)
 
     if failed:
@@ -3234,7 +3243,10 @@ def uptodate(name, refresh=False, pkgs=None, **kwargs):
         try:
             packages = __salt__["pkg.list_upgrades"](refresh=refresh, **kwargs)
             expected = {
-                pkgname: {"new": pkgver, "old": __salt__["pkg.version"](pkgname)}
+                pkgname: {
+                    "new": pkgver,
+                    "old": __salt__["pkg.version"](pkgname, **kwargs),
+                }
                 for pkgname, pkgver in six.iteritems(packages)
             }
             if isinstance(pkgs, list):
@@ -3424,7 +3436,7 @@ def group_installed(name, skip=None, include=None, **kwargs):
             )
         return ret
 
-    failed = [x for x in targets if x not in __salt__["pkg.list_pkgs"]()]
+    failed = [x for x in targets if x not in __salt__["pkg.list_pkgs"](**kwargs)]
     if failed:
         ret["comment"] = "Failed to install the following packages: {0}".format(
             ", ".join(failed)
diff --git a/tests/unit/modules/test_rpm_lowpkg.py b/tests/unit/modules/test_rpm_lowpkg.py
index dda70a6e940a0..b2351d3b091f7 100644
--- a/tests/unit/modules/test_rpm_lowpkg.py
+++ b/tests/unit/modules/test_rpm_lowpkg.py
@@ -15,6 +15,11 @@
 from tests.support.unit import TestCase
 
 
+def _called_with_root(mock):
+    cmd = " ".join(mock.call_args[0][0])
+    return cmd.startswith("rpm --root /")
+
+
 class RpmTestCase(TestCase, LoaderModuleMockMixin):
     """
     Test cases for salt.modules.rpm
@@ -23,7 +28,7 @@ class RpmTestCase(TestCase, LoaderModuleMockMixin):
     def setup_loader_modules(self):
         return {rpm: {"rpm": MagicMock(return_value=MagicMock)}}
 
-    # 'list_pkgs' function tests: 1
+    # 'list_pkgs' function tests: 2
 
     def test_list_pkgs(self):
         """
@@ -32,21 +37,45 @@ def test_list_pkgs(self):
         mock = MagicMock(return_value="")
         with patch.dict(rpm.__salt__, {"cmd.run": mock}):
             self.assertDictEqual(rpm.list_pkgs(), {})
+            self.assertFalse(_called_with_root(mock))
+
+    def test_list_pkgs_root(self):
+        """
+        Test if it list the packages currently installed in a dict,
+        called with root parameter
+        """
+        mock = MagicMock(return_value="")
+        with patch.dict(rpm.__salt__, {"cmd.run": mock}):
+            rpm.list_pkgs(root="/")
+            self.assertTrue(_called_with_root(mock))
 
-    # 'verify' function tests: 1
+    # 'verify' function tests: 2
 
     def test_verify(self):
         """
-        Test if it runs an rpm -Va on a system,
-        and returns the results in a dict
+        Test if it runs an rpm -Va on a system, and returns the
+        results in a dict
         """
         mock = MagicMock(
             return_value={"stdout": "", "stderr": "", "retcode": 0, "pid": 12345}
         )
         with patch.dict(rpm.__salt__, {"cmd.run_all": mock}):
             self.assertDictEqual(rpm.verify("httpd"), {})
+            self.assertFalse(_called_with_root(mock))
 
-    # 'file_list' function tests: 1
+    def test_verify_root(self):
+        """
+        Test if it runs an rpm -Va on a system, and returns the
+        results in a dict, called with root parameter
+        """
+        mock = MagicMock(
+            return_value={"stdout": "", "stderr": "", "retcode": 0, "pid": 12345}
+        )
+        with patch.dict(rpm.__salt__, {"cmd.run_all": mock}):
+            rpm.verify("httpd", root="/")
+            self.assertTrue(_called_with_root(mock))
+
+    # 'file_list' function tests: 2
 
     def test_file_list(self):
         """
@@ -55,8 +84,20 @@ def test_file_list(self):
         mock = MagicMock(return_value="")
         with patch.dict(rpm.__salt__, {"cmd.run": mock}):
             self.assertDictEqual(rpm.file_list("httpd"), {"errors": [], "files": []})
+            self.assertFalse(_called_with_root(mock))
+
+    def test_file_list_root(self):
+        """
+        Test if it list the files that belong to a package, using the
+        root parameter.
+        """
+
+        mock = MagicMock(return_value="")
+        with patch.dict(rpm.__salt__, {"cmd.run": mock}):
+            rpm.file_list("httpd", root="/")
+            self.assertTrue(_called_with_root(mock))
 
-    # 'file_dict' function tests: 1
+    # 'file_dict' function tests: 2
 
     def test_file_dict(self):
         """
@@ -65,6 +106,16 @@ def test_file_dict(self):
         mock = MagicMock(return_value="")
         with patch.dict(rpm.__salt__, {"cmd.run": mock}):
             self.assertDictEqual(rpm.file_dict("httpd"), {"errors": [], "packages": {}})
+            self.assertFalse(_called_with_root(mock))
+
+    def test_file_dict_root(self):
+        """
+        Test if it list the files that belong to a package
+        """
+        mock = MagicMock(return_value="")
+        with patch.dict(rpm.__salt__, {"cmd.run": mock}):
+            rpm.file_dict("httpd", root="/")
+            self.assertTrue(_called_with_root(mock))
 
     # 'owner' function tests: 1
 
@@ -78,6 +129,7 @@ def test_owner(self):
         mock = MagicMock(return_value=ret)
         with patch.dict(rpm.__salt__, {"cmd.run_stdout": mock}):
             self.assertEqual(rpm.owner("/usr/bin/salt-jenkins-build"), "")
+            self.assertFalse(_called_with_root(mock))
 
         ret = {
             "/usr/bin/vim": "vim-enhanced-7.4.160-1.e17.x86_64",
@@ -91,8 +143,22 @@ def test_owner(self):
         )
         with patch.dict(rpm.__salt__, {"cmd.run_stdout": mock}):
             self.assertDictEqual(rpm.owner("/usr/bin/python", "/usr/bin/vim"), ret)
+            self.assertFalse(_called_with_root(mock))
 
-    # 'checksum' function tests: 1
+    def test_owner_root(self):
+        """
+        Test if it return the name of the package that owns the file,
+        using the parameter root.
+        """
+        self.assertEqual(rpm.owner(), "")
+
+        ret = "file /usr/bin/salt-jenkins-build is not owned by any package"
+        mock = MagicMock(return_value=ret)
+        with patch.dict(rpm.__salt__, {"cmd.run_stdout": mock}):
+            rpm.owner("/usr/bin/salt-jenkins-build", root="/")
+            self.assertTrue(_called_with_root(mock))
+
+    # 'checksum' function tests: 2
 
     def test_checksum(self):
         """
@@ -109,6 +175,17 @@ def test_checksum(self):
             self.assertDictEqual(
                 rpm.checksum("file1.rpm", "file2.rpm", "file3.rpm"), ret
             )
+            self.assertFalse(_called_with_root(mock))
+
+    def test_checksum_root(self):
+        """
+        Test if checksum validate as expected, using the parameter
+        root
+        """
+        mock = MagicMock(side_effect=[True, 0])
+        with patch.dict(rpm.__salt__, {"file.file_exists": mock, "cmd.retcode": mock}):
+            rpm.checksum("file1.rpm", root="/")
+            self.assertTrue(_called_with_root(mock))
 
     def test_version_cmp_rpm(self):
         """
diff --git a/tests/unit/modules/test_zypperpkg.py b/tests/unit/modules/test_zypperpkg.py
index afb8547ad102c..7a9e8e3eda02c 100644
--- a/tests/unit/modules/test_zypperpkg.py
+++ b/tests/unit/modules/test_zypperpkg.py
@@ -35,6 +35,9 @@ def __getattr__(self, item):
         return self
 
     def __call__(self, *args, **kwargs):
+        # If the call is for a configuration modifier, we return self
+        if any(i in kwargs for i in ("no_repo_failure", "systemd_scope", "root")):
+            return self
         return MagicMock(return_value=self.__return_value)()
 
 
@@ -875,6 +878,7 @@ def _add_data(data, key, value):
         ):
             pkgs = zypper.list_pkgs(versions_as_list=True)
             self.assertFalse(pkgs.get("gpg-pubkey", False))
+            self.assertTrue("pkg.list_pkgs_None_[]" in zypper.__context__)
             for pkg_name, pkg_version in {
                 "jakarta-commons-discovery": ["0.4-129.686"],
                 "yast2-ftp-server": ["3.1.8-8.1"],
@@ -928,6 +932,7 @@ def _add_data(data, key, value):
                 attr=["epoch", "release", "arch", "install_date_time_t"]
             )
             self.assertFalse(pkgs.get("gpg-pubkey", False))
+            self.assertTrue("pkg.list_pkgs_None_[]" in zypper.__context__)
             for pkg_name, pkg_attr in {
                 "jakarta-commons-discovery": [
                     {
@@ -1397,6 +1402,44 @@ def test_install_advisory_patch_failure(self):
                 ):
                     zypper.install(advisory_ids=["SUSE-PATCH-XXX"])
 
+    @patch("salt.modules.zypperpkg._systemd_scope", MagicMock(return_value=False))
+    @patch(
+        "salt.modules.zypperpkg.list_products",
+        MagicMock(return_value={"openSUSE": {"installed": False, "summary": "test"}}),
+    )
+    @patch(
+        "salt.modules.zypperpkg.list_pkgs",
+        MagicMock(
+            side_effect=[{"product:openSUSE": "15.2"}, {"product:openSUSE": "15.3"}]
+        ),
+    )
+    def test_install_product_ok(self):
+        """
+        Test successfully product installation.
+        """
+        with patch.dict(
+            zypper.__salt__,
+            {
+                "pkg_resource.parse_targets": MagicMock(
+                    return_value=(["product:openSUSE"], None)
+                )
+            },
+        ):
+            with patch(
+                "salt.modules.zypperpkg.__zypper__.noraise.call", MagicMock()
+            ) as zypper_mock:
+                ret = zypper.install("product:openSUSE", includes=["product"])
+                zypper_mock.assert_called_once_with(
+                    "--no-refresh",
+                    "install",
+                    "--auto-agree-with-licenses",
+                    "--name",
+                    "product:openSUSE",
+                )
+                self.assertDictEqual(
+                    ret, {"product:openSUSE": {"old": "15.2", "new": "15.3"}}
+                )
+
     def test_remove_purge(self):
         """
         Test package removal
@@ -1412,7 +1455,7 @@ def __init__(self):
                     "pico": "0.1.1",
                 }
 
-            def __call__(self):
+            def __call__(self, root=None, includes=None):
                 pkgs = self._pkgs.copy()
                 for target in self._packages:
                     if self._pkgs.get(target):
@@ -1475,9 +1518,12 @@ def test_repo_add_nomod_noref(self):
         with zypper_patcher:
             zypper.mod_repo(name, **{"url": url})
             self.assertEqual(
-                zypper.__zypper__.xml.call.call_args_list, [call("ar", url, name)]
+                zypper.__zypper__(root=None).xml.call.call_args_list,
+                [call("ar", url, name)],
+            )
+            self.assertTrue(
+                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
             )
-            self.assertTrue(zypper.__zypper__.refreshable.xml.call.call_count == 0)
 
     def test_repo_noadd_nomod_noref(self):
         """
@@ -1501,8 +1547,10 @@ def test_repo_noadd_nomod_noref(self):
                 out["comment"],
                 "Specified arguments did not result in modification of repo",
             )
-            self.assertTrue(zypper.__zypper__.xml.call.call_count == 0)
-            self.assertTrue(zypper.__zypper__.refreshable.xml.call.call_count == 0)
+            self.assertTrue(zypper.__zypper__(root=None).xml.call.call_count == 0)
+            self.assertTrue(
+                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
+            )
 
     def test_repo_noadd_modbaseurl_ref(self):
         """
@@ -1532,10 +1580,11 @@ def test_repo_noadd_modbaseurl_ref(self):
                 "cache": False,
                 "keeppackages": False,
                 "type": "rpm-md",
+                "root": None,
             }
-            self.assertTrue(zypper.mod_repo.call_count == 2)
-            self.assertTrue(
-                zypper.mod_repo.mock_calls[1] == call(name, **expected_params)
+            self.assertEqual(zypper.mod_repo.call_count, 2)
+            self.assertEqual(
+                zypper.mod_repo.mock_calls[1], call(name, **expected_params)
             )
 
     def test_repo_add_mod_noref(self):
@@ -1553,9 +1602,10 @@ def test_repo_add_mod_noref(self):
         with zypper_patcher:
             zypper.mod_repo(name, **{"url": url, "refresh": True})
             self.assertEqual(
-                zypper.__zypper__.xml.call.call_args_list, [call("ar", url, name)]
+                zypper.__zypper__(root=None).xml.call.call_args_list,
+                [call("ar", url, name)],
             )
-            zypper.__zypper__.refreshable.xml.call.assert_called_once_with(
+            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                 "mr", "--refresh", name
             )
 
@@ -1576,8 +1626,8 @@ def test_repo_noadd_mod_noref(self):
         )
         with zypper_patcher:
             zypper.mod_repo(name, **{"url": url, "refresh": True})
-            self.assertTrue(zypper.__zypper__.xml.call.call_count == 0)
-            zypper.__zypper__.refreshable.xml.call.assert_called_once_with(
+            self.assertTrue(zypper.__zypper__(root=None).xml.call.call_count == 0)
+            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                 "mr", "--refresh", name
             )
 
@@ -1597,13 +1647,15 @@ def test_repo_add_nomod_ref(self):
         with zypper_patcher:
             zypper.mod_repo(name, **{"url": url, "gpgautoimport": True})
             self.assertEqual(
-                zypper.__zypper__.xml.call.call_args_list,
+                zypper.__zypper__(root=None).xml.call.call_args_list,
                 [
                     call("ar", url, name),
                     call("--gpg-auto-import-keys", "refresh", name),
                 ],
             )
-            self.assertTrue(zypper.__zypper__.refreshable.xml.call.call_count == 0)
+            self.assertTrue(
+                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
+            )
 
     def test_repo_noadd_nomod_ref(self):
         """
@@ -1625,10 +1677,12 @@ def test_repo_noadd_nomod_ref(self):
         with zypper_patcher:
             zypper.mod_repo(name, **{"url": url, "gpgautoimport": True})
             self.assertEqual(
-                zypper.__zypper__.xml.call.call_args_list,
+                zypper.__zypper__(root=None).xml.call.call_args_list,
                 [call("--gpg-auto-import-keys", "refresh", name)],
             )
-            self.assertTrue(zypper.__zypper__.refreshable.xml.call.call_count == 0)
+            self.assertTrue(
+                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
+            )
 
     def test_repo_add_mod_ref(self):
         """
@@ -1649,13 +1703,13 @@ def test_repo_add_mod_ref(self):
                 name, **{"url": url, "refresh": True, "gpgautoimport": True}
             )
             self.assertEqual(
-                zypper.__zypper__.xml.call.call_args_list,
+                zypper.__zypper__(root=None).xml.call.call_args_list,
                 [
                     call("ar", url, name),
                     call("--gpg-auto-import-keys", "refresh", name),
                 ],
             )
-            zypper.__zypper__.refreshable.xml.call.assert_called_once_with(
+            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                 "--gpg-auto-import-keys", "mr", "--refresh", name
             )
 
@@ -1681,10 +1735,10 @@ def test_repo_noadd_mod_ref(self):
                 name, **{"url": url, "refresh": True, "gpgautoimport": True}
             )
             self.assertEqual(
-                zypper.__zypper__.xml.call.call_args_list,
+                zypper.__zypper__(root=None).xml.call.call_args_list,
                 [call("--gpg-auto-import-keys", "refresh", name)],
             )
-            zypper.__zypper__.refreshable.xml.call.assert_called_once_with(
+            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                 "--gpg-auto-import-keys", "mr", "--refresh", name
             )
 
@@ -1877,3 +1931,55 @@ def test_wildcard_to_query_unsupported_operators(self):
         with self.assertRaises(CommandExecutionError):
             for op in [">>", "==", "<<", "+"]:
                 zypper.Wildcard(_zpr)("libzypp", "{0}*.1".format(op))
+
+    @patch("salt.modules.zypperpkg._get_visible_patterns")
+    def test__get_installed_patterns(self, get_visible_patterns):
+        """Test installed patterns in the system"""
+        get_visible_patterns.return_value = {
+            "package-a": {"installed": True, "summary": "description a"},
+            "package-b": {"installed": False, "summary": "description b"},
+        }
+
+        salt_mock = {
+            "cmd.run": MagicMock(
+                return_value="""pattern() = package-a
+pattern-visible()
+pattern() = package-c"""
+            ),
+        }
+        with patch.dict("salt.modules.zypperpkg.__salt__", salt_mock):
+            assert zypper._get_installed_patterns() == {
+                "package-a": {"installed": True, "summary": "description a"},
+                "package-c": {"installed": True, "summary": "Non-visible pattern"},
+            }
+
+    @patch("salt.modules.zypperpkg._get_visible_patterns")
+    def test_list_patterns(self, get_visible_patterns):
+        """Test available patterns in the repo"""
+        get_visible_patterns.return_value = {
+            "package-a": {"installed": True, "summary": "description a"},
+            "package-b": {"installed": False, "summary": "description b"},
+        }
+        assert zypper.list_patterns() == {
+            "package-a": {"installed": True, "summary": "description a"},
+            "package-b": {"installed": False, "summary": "description b"},
+        }
+
+    def test__clean_cache_empty(self):
+        """Test that an empty cached can be cleaned"""
+        context = {}
+        with patch.dict(zypper.__context__, context):
+            zypper._clean_cache()
+            assert context == {}
+
+    def test__clean_cache_filled(self):
+        """Test that a filled cached can be cleaned"""
+        context = {
+            "pkg.list_pkgs_/mnt_[]": None,
+            "pkg.list_pkgs_/mnt_[patterns]": None,
+            "pkg.list_provides": None,
+            "pkg.other_data": None,
+        }
+        with patch.dict(zypper.__context__, context):
+            zypper._clean_cache()
+            self.assertEqual(zypper.__context__, {"pkg.other_data": None})
diff --git a/tests/unit/states/test_pkg.py b/tests/unit/states/test_pkg.py
index b0ced9fd29026..15ca937e1340e 100644
--- a/tests/unit/states/test_pkg.py
+++ b/tests/unit/states/test_pkg.py
@@ -39,7 +39,7 @@ def test_uptodate_with_changes(self):
             }
         )
         upgrade = MagicMock(return_value=self.pkgs)
-        version = MagicMock(side_effect=lambda pkgname: self.pkgs[pkgname]["old"])
+        version = MagicMock(side_effect=lambda pkgname, **_: self.pkgs[pkgname]["old"])
 
         with patch.dict(
             pkg.__salt__,
@@ -52,7 +52,6 @@ def test_uptodate_with_changes(self):
 
             # Run state with test=false
             with patch.dict(pkg.__opts__, {"test": False}):
-
                 ret = pkg.uptodate("dummy", test=True)
                 self.assertTrue(ret["result"])
                 self.assertDictEqual(ret["changes"], self.pkgs)
@@ -80,7 +79,7 @@ def test_uptodate_with_pkgs_with_changes(self):
             }
         )
         upgrade = MagicMock(return_value=self.pkgs)
-        version = MagicMock(side_effect=lambda pkgname: pkgs[pkgname]["old"])
+        version = MagicMock(side_effect=lambda pkgname, **_: pkgs[pkgname]["old"])
 
         with patch.dict(
             pkg.__salt__,
@@ -181,7 +180,7 @@ def test_uptodate_with_failed_changes(self):
             }
         )
         upgrade = MagicMock(return_value={})
-        version = MagicMock(side_effect=lambda pkgname: pkgs[pkgname]["old"])
+        version = MagicMock(side_effect=lambda pkgname, **_: pkgs[pkgname]["old"])
 
         with patch.dict(
             pkg.__salt__,
